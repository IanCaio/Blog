---
layout: blogpost
title:  "Making comment sections with Staticman - Part 2"
author: "Ian Caio"
date:   2018-01-20 16:57:42 -0200
header-image: "/imgs/posts/2/staticman.png"
comment-section: "https://iancaio.github.io/blog-comments/get/post3comments.json"
comment-post-link: "https://api.staticman.net/v2/entry/IanCaio/blog-comments/master/post3comments"
category: "Front-End"
---
On the second part of this articles series I describe the overview of the idea I had
for my comment system and how I took the first step of making it work: Setting up the
comment database page.

[Click here]({{ site.baseurl }}{{ page.previous.url }})
if you haven't read the first article and want to take a look at it!

*DISCLAIMER: This article was made for educational purposes only. The comment system was just
recently deployed and is still under testing. It seems functional and bug free, but I'm not
responsable for the misuse of the code or any consequences that might arise from using it
on production websites.*
{: .small-text .extra-margin }

## Overview of the approach
{: .center }

When trying to put an idea into practice, most of the time we have to adapt our original
concepts to the constraints we find along the way. With this one it wasn't any different.
My constraints here were linked directly to the fact that the blog page and the comment database
page are both static. That means I'm limited to using client-side scripts and Jekyll (the
Github pages static site generator).
As for the basic prerequisites I had for the comment section, basically it should be
compartmentalized and allow nested comments.

With that in mind, my idea for the comment section consisted of storing the comments
as JSON files containing all the information of a single comment. Those would be the user name,
the date it was posted, the comment body, a github account (if provided), an unique comment
ID and the parent's comment ID in the case the comment is a reply. The repository that is
going to behave as a comment database is going to build a dynamic JSON object which is going
to be a tree, listing all the comments in the order they were posted and nesting them in
order of hierarchy. This dynamic object gets rebuilt by Jekyll everytime a new comment is added.

<figure class="center medium">
<img src="{{ site.baseurl }}/imgs/posts/3/CommentsOBJMap.svg" alt="Comments Tree" />
<figcaption>Dynamic Comment Object</figcaption>
</figure>

## Setting up the comment database repository

First step was to create the comment database Github repository. This repository is the one Staticman
will have access to and post comments in. It will also be the one responsable by creating the dynamic
JSON object with the comments tree.

Go to Github, create a repository (i.e.: "blog-comments"), set up a basic Jekyll page on it and change
the repository to enable Github Pages. Then you should follow the
[instructions](https://staticman.net/docs/index.html) on Staticman's website on how to set up Staticman
to that repository and add the `staticman.yml` configuration file.

I'll not go in many details on all the available Staticman configurations, since they are described
on the [official website](https://staticman.net/docs/configuration), but I'll overview the ones being
used in my particular comment database. The following configuration property snippet should be added
for **each** comment section you have:

```yml
examplecomments:
  allowedFields: ["parent", "github", "name", "comment"]
  branch: "master"
  filename: "{@timestamp}-{@id}"
  format: "json"
  moderation: false
  path: "_data/examplecomments"
  requiredFields: ["name", "comment"]
  generatedFields:
    date:
      type: date
      options:
      format: "iso8601"
```

The `allowedFields` parameter will describe all the fields acceptable by Staticman, while `requiredFields`
will describe the ones required by it. The ones we require are "name" and "comment", since we don't force
the user to provide a Github account (used only for displaying the avatar) and the "parent" field is
exclusive of replies.

The `moderation` parameter is set to false, to allow Staticman to commit the changes without opening
a pull request, but I advise you to use `moderation: true` before you extensively test the code for bugs.
We set the format Staticman will save the comments to `json`. The `generatedFields`
parameter is a list of fields that should be automatically generated by Staticman when a comment
is submitted. Here, we just add the date in the _iso8601_ format so we can display it in the comments. 

Something very important here is the `filename` field. `{@timestamp}-{@id}` value tells Staticman to fill
the filename with the Unix timestamp in millisecs, a "-" character and the unique comment ID. That name
convention will be later used to sort the comments in the order they were posted on the dynamic JSON
object tree.

You probably noticed I didn't include anything about the ID field. That's because Staticman will
automatically add the comment unique ID in a field named `_id`. The `path` parameter will determine
the folder where Staticman will save the comment files and it should be unique for each comment section
you have.

## Writing the dynamic JSON comment tree generator

This is where things started getting a little complicated. [Jekyll](https://jekyllrb.com/) allows you to use
Liquid Template to dynamically modify a static page. On Github Pages, that happens everytime you add some content to the
repository.
It's perfect for blogs, where you want to add a link to all the posts on a index page, or maybe add some content to a
pre-defined layout. However, Jekyll and Liquid are not supposed to be a programming language, so anything that gets too complex
becomes a *pain in the ass* to be done with them, pardon my french.

<figure class="center medium">
<img src="{{ site.baseurl }}/imgs/posts/3/JekyllLogo.png" alt="Jekyll Logo" />
</figure>

To be able to markup nested comments in an elegant way, I wanted to have a `<div>` for each comment.
If the comment is a reply to any other comment, instead of being placed in the comment section's `<div>`
it would be added inside the comment's `<div>` it was replying to:

```html
<div class="post-content">
  ... <!-- Talks about life -->
  <div class="comment-section">
    <div class="comment">
      ... <!-- Some comment -->
    </div>
    <div class="comment">
      ... <!-- Another comment -->
      <div class="comment">
        ... <!-- This comment is a reply -->
      </div>
    </div>
  </div>
</div>
```

So the dynamic JSON object should fit that layout, by making a tree with a list of comments. Each
comment would be an object with the properties associated with it and, **if** it has any replies,
a particular property that would be an array with all the replies comment objects. It's something that
can be better understood visualized:

```json
[{
  {
    "name":"Mike",
    "comment":"Hello!"
  },
  {
    "name":"John",
    "comment":"Hello world!"
    "reply": [{
              "name":"Lisa",
              "comment":"Hello John!"
            },
            {
              "name":"Peter",
              "comment":"Hi mate!",
              "reply": [{
                          "name":"Lisa",
                          "comment":"Hey Peter!"
                        }]
            }]
  }
}]
```

On the previous example of a very meaningless conversation, we have two root comments:
one from Mike and one from John. John's comment have two replies, one from Lisa and one from Peter,
stored in the `reply` field array. Peter's comment also has a reply from Lisa, and if we had more
replies it would go on and on.

Can you feel the smell of **recursion**?

The problem is, like I said, the Jekyll/Liquid combo is great for static website generation. But terrible for
more complex programming tasks like the ones which require recursion. It's just not what they were designed
for.

So what do we do?

We make some _fake recursion_. That is, we simulate the recursion by simply repeating the code over and over,
the number of times needed to clear most realistic case scenarios (I was wondering if that would
classify as some sort of [loop unrolling](https://en.wikipedia.org/wiki/Loop_unrolling)...). Since the
code will follow a well-defined pattern, you can write a script that will write the repeated code for you,
or use the one I have in my [comment database](https://iancaio.github.io/blog-comments/comment-tree-generator).

So what will the Liquid Template code look like? It will have to iterate through all the files in
the folder containing the page's comments. It will then check if the comment JSON object has a
`parent` key. If it doesn't, means we have a root comment, so we add it to the comment tree and
fill all the fields. Before closing the comment's object, we iterate through all the files in the
folder again, but this time checking for comments that have a `parent` value equal to the current
comment's ID. If none is found we simply close the object and keep adding the other comments.
If one is found, we add it and repeat the process.

Here is what the Liquid Template code would look like for a comment section of up to 3 nesting levels:

{% raw %}
```yaml
---
---
[
{%- assign level1_first_obj = true -%}
{%- assign folder_files1 = site.data.examplecomments | sort -%}
{%- for level1_file in folder_files1 -%}
{%- assign level1 = level1_file[1] -%}
{%- unless level1.parent -%}
{%- if level1_first_obj == false -%}
,
{%- endif -%}
{%- assign level1_first_obj = false -%}
{
"id":{{ level1._id | jsonify }},
"name":{{ level1.name | jsonify }},
{% if level1.github %}
"github":{{ level1.github | jsonify }},
{% endif %}
"date":{{ level1.date | jsonify }},
"comment":{{ level1.comment | jsonify }}
{%- assign level1_children = false -%}
{%- for all_files in site.data.examplecomments -%}
{%- if all_files[1].parent == level1._id -%}
{%- assign level1_children = true -%}
{%- break -%}
{%- endif -%}
{%- endfor -%}
{%- if level1_children == true -%}
,"reply": [
{%- assign level2_first_obj = true -%}
{%- assign folder_files2 = site.data.examplecomments | sort -%}
{%- for level2_file in folder_files2 -%}
{%- assign level2 = level2_file[1] -%}
{%- if level2.parent == level1._id -%}
{%- if level2_first_obj == false -%}
,
{%- endif -%}
{%- assign level2_first_obj = false -%}
{
"id":{{ level2._id | jsonify }},
"name":{{ level2.name | jsonify }},
{% if level2.github %}
"github":{{ level2.github | jsonify }},
{% endif %}
"date":{{ level2.date | jsonify }},
"comment":{{ level2.comment | jsonify }}
{%- assign level2_children = false -%}
{%- for all_files in site.data.examplecomments -%}
{%- if all_files[1].parent == level2._id -%}
{%- assign level2_children = true -%}
{%- break -%}
{%- endif -%}
{%- endfor -%}
{%- if level2_children == true -%}
,"reply": [
{%- assign level3_first_obj = true -%}
{%- assign folder_files3 = site.data.examplecomments | sort -%}
{%- for level3_file in folder_files3 -%}
{%- assign level3 = level3_file[1] -%}
{%- if level3.parent == level2._id -%}
{%- if level3_first_obj == false -%}
,
{%- endif -%}
{%- assign level3_first_obj = false -%}
{
"id":{{ level3._id | jsonify }},
"name":{{ level3.name | jsonify }},
{% if level3.github %}
"github":{{ level3.github | jsonify }},
{% endif %}
"date":{{ level3.date | jsonify }},
"comment":{{ level3.comment | jsonify }}
}
{%- endif -%}
{%- endfor -%}
]
{%- endif -%}
}
{%- endif -%}
{%- endfor -%}
]
{%- endif -%}
}
{%- endunless -%}
{%- endfor -%}
]
```
{: .medium-box }
{% endraw %}

### Some code lines explained
{: .center }

{% raw %}
`{%- assign level1_first_obj = true -%}`{: .language-yaml}: Variable that tells if the object being
added in the current level is the first one. It's used to find out if we need to add a _comma_ before
appending the object. Otherwise we would have `[{"object":"1"}{"object":"2"}]`{: .language-json} which
is invalid JSON.

`{%- assign folder_files1 = site.data.examplecomments | sort -%}`{: .language-yaml}: Variable that will
hold a list of the alphabetically sorted comments in the *_data/examplecomments* folder of your comment
database.

`{%- for level1_file in folder_files1 -%}`{: .language-yaml}: Iterates through all the files from the
comment folder alphabetically.

`{%- assign level1 = level1_file[1] -%}`{: .language-yaml}: Accesses the actual data in the current
file.

`{%- unless level1.parent -%}`{: .language-yaml}: Since we are in the root level (level 1), we only add
the comment to the object tree if it doesn't have a parent.

`"name":{{ level1.name | jsonify }},`{: .language-yaml}: Adds information to the comment object.
We apply the `jsonify` filter to convert the content of the property to JSON format (this will escape
newlines, tabs and other invalid characters on the JSON file, also adding the surrounding quotes).

`{%- if level1_children == true -%},"reply": [`{: .language-yaml}: Previously to that line, we iterated through all
the files in the *_data/examplecomments* folder and checked if any of them have a `parent` key with a value
equal to the current comment ID. If any of them have, we add the `reply` field and start the next level loop
to fill the `reply` array with those.

`{%- if level2.parent == level1._id -%}`{: .language-yaml}: While iterating all the comments on the second
nesting level, we only add them to the `reply` array if their `parent` value is equal to the current comment ID.
{: .extra-margin }
{% endraw %}

I believe the previous pieces of the code are the most important to understand what the script is doing.
I didn't chose a 3 level snippet randomly, but because it's the smallest snippet where you'll notice the
3 patterns that will be present on every single generated code, regardless of how many levels you'll iterate:
The pattern for the root level (level 1) comments, the pattern for comments that are not in the
first nor in the last level (level 2) and the pattern for the comments in the last level (level 3).

What my [comment tree generator](https://iancaio.github.io/blog-comments/comment-tree-generator)
does is simply organize and repeat those patterns for the ammount
of times you ask it to, replace the level numbers on the places they should be replaced and use
the defined folder variable (i.e.: `site.data.examplecomments`).

When there are comments in the folder that are nested in a higher level than what's supported by the file
you generate, they will simply be ignored. I believe 10 nesting levels should be enough, since anything
close to that will be visually annoying, and unless you have a very high traffic page isn't very likely
to happen. If you have lots of traffic you could just set it for a very high number. I don't even think
it will affect performance that much, because the inner loops will only be ran if we actually find a file
on that nesting level (so if you have 100 nesting levels, the 100th level loop piece of the code will not be reached
unless there is a file on that level). **But that's only an assumption!**

After generating the dynamic JSON object tree file, you can save it in a place like `/get/examplecomments.json`.
By doing that, when you request the file from `https://username.github.io/comment-database/get/examplecomments.json`,
you will fetch the final generated JSON object tree.
{: .extra-margin}

#### [Check this blog comment database!](https://github.com/IanCaio/blog-comments)
{: .center .extra-margin}

This step of building the comment system is probably the hardest one. Hopefully I did at least a decent job
explaining it. If you think I could improve something in the explanation or have any doubts feel free
to comment below.

On the next article I'll go into how to use Javascript and AJAX to actually fetch the comment tree and
use it to fill the comment section.

#### [Go back to part 1]({{ site.baseurl }}{{ page.previous.url }})
